-- Feb 20, 2009

DONE Fix glXCreateWindow and glXDestroyWindow.

DONE Add API major version testing to the apple_cgl layer.  This way we can avoid
future API fiascos.  Jordan suggested this a while ago.

-- Feb 16, 2009

DONE glXMakeContextCurrent's readable drawable needs to be set as the current 
surface/pbuffer/pixmap if it's different than the normal drawable in the 
following routines:
glReadPixels, glCopyPixels, glCopyColorTable

DONE The old surface/pbuffer/pixmap needs to be restored after that.

DONE glXGetCurrentReadDrawable should also report the read drawable.  It appears correct.

DONE Test glXGetCurrentDisplay().  It appears correct.
--

DONE Improve the glX symbol compatibility with the old libGL.

DONE Work out something for the GLXFBConfig optimal width/height.  These types
of things aren't really exposed AFAIK by CGL.  We can't do this, so we
don't enable the extension that enables the optimal pbuffer width/height.
Specifically don't enable the SGIX_pbuffer:
#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX     0x8019
#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX    0x801A

Verify the XError behavior of GLXPixmap support functions.

Test GLXPixmap support with various pixmap depths.
 
Test GLXPixmap support with invalid pixmaps (to stress the protocol code).

DONE Make apple_visual_create_pfobj not use OffScreen always.
I suspect we can add a bool that indicates whether or not to create such
an object.  We can also recreate the context, or possibly reconfigure it.
Perhaps we could store the CGL attributes used for the pixel format object, and
append the OFfScreen attribute when using GLXPixmaps.

DONE Finish glXDestroyGLXPixmap().

DONE Test glXDestroyGLXPixmap().

DONE Add support for the newer glXCreatePixmap (from 1.4).  We have glXCreateGLXPixmap working.

-- Feb 10, 2009

Test glXCopyContext.

DONE (in 1.6) Add the PBUFFER_BIT to the fbconfigs/visualconfigs in the X server.  This is actually unclear.  We should perhaps set that bit in the libGL instead.

DONE Test the pbuffer by using glReadPixels to verify it's being written to.

DONE PLAN Handle GLX_LARGEST_PBUFFER (it's unclear how to handle this so far).

DONE glXQueryDrawable support for Pbuffer drawables.

DONE make glXSelectEvent() a no-op.

-- Feb 9, 2009

DONE Add glDrawBuffersARB to the exclusion list, and make it forward to the glDrawBuffers().

-- Feb 7, 2009

DONE Extend the GL_aliases for compatibility with the old libGL (wherever possible).


-- Feb 5, 2009

DONE glXUseXFont needs the xfont.c code imported from Mesa.

DONE Test Chimera with AppleSGLX.

DONE Test Pymol again with AppleSGLX.

-- Jan 16, 2009

(from my paper notes)

DONE: glXSwapBuffers should do an implicit glFlush according to the GLX 1.4 spec.

DONE The first time a context is made current we should set the glViewport and glScissor according to the GLX 1.4 spec to the size of the new drawable.

DONE test glXQueryServerString, glXGetClientString, and glXGetProcAddress.

DONE Use CGLGetVersion to assert ABI major version compatibility with the OpenGL framework.

DONE Work out the include/GL/gl.h problems (with the ARB functions).

DONE Install the new headers with the install target.

-- Dec 28, 2008

DONE Fix the missing #define for glxinfo IIRC or one of the glx-based programs from Mesa.  We need to define the necessary functions and features for the relevant GL and GLX extensions.  I also need to find a good indication of what extensions to enable on the server side for telling clients what we support.


-- Dec 12 2008
 
Generate include/GL/gl.h as needed.

DONE TEST Shared contexts may work now, test them.

DONE DestroyContext needs some work perhaps for the drawable destruction.

TEST glXCopyContext needs some work and additional code in apple_glx.c.

-- OLD:

DONE Add glxext.h support, and support functions.

----


Don't forget to check with otool -L to make sure the right library is being used before release!

Make sure we report the proper list of GLX extensions available.  Apple direct may not support some that Mesa does, and vice-versa.

Modify create_destroy_context and create a new test called create_destroy_context_thread_race.  Where 2 threads are doing the same sort of path of create and destroy.  The locking should protect us there, but we need to verify nothing goes wrong.

